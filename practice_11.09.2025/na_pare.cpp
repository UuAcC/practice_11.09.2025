//class TSet {
//	int n;
//	int* mem;
//public:
//	TSet(int _n) : n(_n) { mem = new int[n]; }
//};

// вот так получается плохо, пушто хотим хранить 0 и 1, и зачем то используем инты
// хочеца использовать что-то побитовое

// int a = 0 - можно рассмотреть как мн-во на 32 элемента, ни одного из которых нет
// a |= 1 << 5; получим 000001000....000
// a = a | (1 << 5); ИЛИ здесь для того, чтоб когда добавляли вот эту единичку на 5 позицию, 
// ниче другое из массива не удалилось

//int main()
//{
//	uint16_t a = 0; print_bit(a);
//	a |= (1 << 0); print_bit(a); 
//	// вот так добавили бит на позицию 1
//	a |= (1 << 3); print_bit(a);
//	a |= (1 << 4); print_bit(a);
//	a &= ~(1 << 4); print_bit(a);
//	// получили маску, в которой все единички, кроме нужного нам бита
//	// так останется все, кроме этого бита, т.е. убрали элемент
//	// а как проверить наличие?
//	return 0;
//
//	// i >> (sizeof(i) + 1) - вот так получим, какое из четырех чисел нам использовать
//	// сдвиг влево умножает на 2, сдвиг вправо делит на 2
//	// a << 
//}

//int main_()
//{
//	uint32_t a = 35; print_bit(a);
//	int pos = a >> (5); // вот это чтобы получить, в каком мы числе работаем 
//	// (массив хранится в нескольких числах ну крч понял)
//	int pos_val = a & ((1 << 5) - 1); // вот эта шляпа чтобы получить остаток от деления на 1<<4 (16)
//	cout << pos << " " << pos_val << endl;
//}

// в качестве лабы мы реализуем такое множество, т.е. массив